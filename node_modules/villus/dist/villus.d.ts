import { TypedDocumentNode } from '@graphql-typed-document-node/core';
import { DocumentNode, GraphQLError, ExecutionResult } from 'graphql';
import * as vue from 'vue';
import { Ref, App, VNode, UnwrapRef, InjectionKey } from 'vue';

interface GraphQLResponse<TData> {
    data: TData;
    errors: any;
}
interface FetchOptions extends RequestInit {
    url?: string;
    headers: NonNullable<Record<string, string>>;
}
interface ParsedResponse<TData> {
    ok: boolean;
    status: number;
    statusText: string;
    headers: Headers;
    body: GraphQLResponse<TData> | null;
}
interface Operation<TData, TVars> {
    query: string | DocumentNode | TypedDocumentNode<TData, TVars>;
    variables?: TVars;
}

declare class CombinedError extends Error {
    name: 'CombinedError';
    message: string;
    response: any;
    networkError?: Error;
    graphqlErrors?: GraphQLError[];
    constructor({ response, networkError, graphqlErrors, }: {
        response: any;
        networkError?: Error;
        graphqlErrors?: Array<string | GraphQLError | Error>;
    });
    get isGraphQLError(): boolean;
    toString(): string;
}

interface OperationResult<TData = any> {
    data: TData | null;
    error: CombinedError | null;
}
declare type CachePolicy = 'cache-and-network' | 'network-only' | 'cache-first' | 'cache-only';
declare type StandardOperationResult<TData = any> = ExecutionResult<TData>;
declare type QueryVariables = Record<string, any>;
interface ObserverLike<T> {
    next?: (value: T) => void;
    error?: (err: any) => void;
    complete?: () => void;
}
interface Unsubscribable {
    unsubscribe: () => void;
}
/** An abstract observable interface conforming to: https://github.com/tc39/proposal-observable */
interface ObservableLike<T> {
    subscribe(observer: ObserverLike<T>): Unsubscribable;
}
declare type MaybeRef<T> = T | Ref<T>;
declare type MaybeLazyOrRef<T> = MaybeRef<T> | (() => T);
declare type OperationType = 'query' | 'mutation' | 'subscription';
declare type AfterQueryCallback = (result: OperationResult, ctx: {
    response?: ParsedResponse<unknown>;
}) => void | Promise<void>;
interface OperationWithCachePolicy<TData, TVars> extends Operation<TData, TVars> {
    cachePolicy?: CachePolicy;
}
declare type ClientPluginOperation = OperationWithCachePolicy<unknown, QueryVariables> & {
    type: OperationType;
    key: number;
};
interface QueryExecutionContext {
    headers: Record<string, string>;
}
interface ClientPluginContext {
    useResult: (result: OperationResult<unknown>, terminate?: boolean) => void;
    afterQuery: (cb: AfterQueryCallback) => void;
    operation: ClientPluginOperation;
    opContext: FetchOptions;
    response?: ParsedResponse<unknown>;
}
declare type ClientPlugin = ({ useResult, operation }: ClientPluginContext) => void | Promise<void>;
declare type SkipQuery<TVars = QueryVariables> = Ref<boolean> | ((variables: TVars) => boolean);

interface ClientOptions {
    url: string;
    cachePolicy?: CachePolicy;
    use?: ClientPlugin[];
}
/**
 * Sets or unsets the active client
 *
 * @param client - villus client instance
 */
declare const setActiveClient: (client: Client | undefined) => Client;
/**
 * Get the currently active client if there is any.
 */
declare const getActiveClient: () => any;
declare type OnResultChangedCallback<TData> = (result: OperationResult<TData>) => unknown;
declare const defaultPlugins: () => ClientPlugin[];
declare class Client {
    install: (app: App) => void;
    private url;
    private defaultCachePolicy;
    private plugins;
    constructor(opts: ClientOptions);
    /**
     * Executes an operation and returns a normalized response.
     */
    private execute;
    executeQuery<TData = any, TVars = QueryVariables>(operation: OperationWithCachePolicy<TData, TVars>, queryContext?: QueryExecutionContext, onResultChanged?: OnResultChangedCallback<TData>): Promise<OperationResult<TData>>;
    executeMutation<TData = any, TVars = QueryVariables>(operation: Operation<TData, TVars>, queryContext?: QueryExecutionContext): Promise<OperationResult<TData>>;
    executeSubscription<TData = any, TVars = QueryVariables>(operation: Operation<TData, TVars>): Promise<ObservableLike<StandardOperationResult<TData>>>;
}
declare function createClient(opts: ClientOptions): Client;

declare const Provider: vue.DefineComponent<{
    url: {
        type: StringConstructor;
        required: true;
    };
    cachePolicy: {
        type: StringConstructor;
        default: CachePolicy;
    };
    use: {
        type: ArrayConstructor;
        default: any;
    };
}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}>[], unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, vue.EmitsOptions, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{
    url: {
        type: StringConstructor;
        required: true;
    };
    cachePolicy: {
        type: StringConstructor;
        default: CachePolicy;
    };
    use: {
        type: ArrayConstructor;
        default: any;
    };
}>>, {
    use: unknown[];
    cachePolicy: string;
}>;
declare function withProvider(component: any, clientOpts: ClientOptions): vue.DefineComponent<{}, () => vue.VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}>, {}, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, vue.EmitsOptions, string, vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, Readonly<vue.ExtractPropTypes<{}>>, {}>;

declare function getQueryKey(operation: Operation<unknown, unknown>, ...components: string[]): number;

interface QueryCompositeOptions<TData, TVars> {
    query: MaybeRef<Operation<TData, TVars>['query']>;
    variables?: MaybeLazyOrRef<TVars>;
    context?: MaybeRef<QueryExecutionContext>;
    cachePolicy?: CachePolicy;
    fetchOnMount?: boolean;
    client?: Client;
    skip?: SkipQuery<TVars>;
}
interface QueryExecutionOpts<TVars> {
    cachePolicy: CachePolicy;
    variables: TVars;
}
interface BaseQueryApi<TData = any, TVars = QueryVariables> {
    data: Ref<TData | null>;
    isFetching: Ref<boolean>;
    isDone: Ref<boolean>;
    error: Ref<CombinedError | null>;
    execute(overrideOpts?: Partial<QueryExecutionOpts<TVars>>): Promise<{
        data: TData | null;
        error: CombinedError | null;
    }>;
    unwatchVariables(): void;
    watchVariables(): void;
    isWatchingVariables: Ref<boolean>;
}
interface QueryApi<TData, TVars> extends BaseQueryApi<TData, TVars> {
    then(onFulfilled: (value: BaseQueryApi<TData, TVars>) => any): Promise<BaseQueryApi<TData, TVars>>;
}
declare function useQuery<TData = any, TVars = QueryVariables>(opts: QueryCompositeOptions<TData, TVars>): QueryApi<TData, TVars>;

declare type QuerySlotProps$1 = UnwrapRef<Pick<BaseQueryApi, 'data' | 'error' | 'execute' | 'isDone' | 'isFetching'>>;
declare const Query: {
    new (...args: any[]): {
        $: vue.ComponentInternalInstance;
        $data: {};
        $props: Partial<{
            suspended: boolean;
            variables: Record<string, any>;
            cachePolicy: string;
            fetchOnMount: boolean;
            watchVariables: boolean;
        }> & Omit<Readonly<vue.ExtractPropTypes<{
            query: {
                type: (ObjectConstructor | StringConstructor)[];
                required: true;
            };
            variables: {
                type: ObjectConstructor;
                default: any;
            };
            cachePolicy: {
                type: StringConstructor;
                default: any;
            };
            watchVariables: {
                type: BooleanConstructor;
                default: boolean;
            };
            suspended: {
                type: BooleanConstructor;
                default: boolean;
            };
            fetchOnMount: {
                type: BooleanConstructor;
                default: boolean;
            };
        }>> & vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, "suspended" | "variables" | "cachePolicy" | "fetchOnMount" | "watchVariables">;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: vue.Slot;
        }>;
        $root: vue.ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, vue.ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>;
        $parent: vue.ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, vue.ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>;
        $emit: (event: string, ...args: any[]) => void;
        $el: any;
        $options: vue.ComponentOptionsBase<Readonly<vue.ExtractPropTypes<{
            query: {
                type: (ObjectConstructor | StringConstructor)[];
                required: true;
            };
            variables: {
                type: ObjectConstructor;
                default: any;
            };
            cachePolicy: {
                type: StringConstructor;
                default: any;
            };
            watchVariables: {
                type: BooleanConstructor;
                default: boolean;
            };
            suspended: {
                type: BooleanConstructor;
                default: boolean;
            };
            fetchOnMount: {
                type: BooleanConstructor;
                default: boolean;
            };
        }>>, BaseQueryApi<any, Record<string, any>>, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, Record<string, any>, string, {
            suspended: boolean;
            variables: Record<string, any>;
            cachePolicy: string;
            fetchOnMount: boolean;
            watchVariables: boolean;
        }> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: vue.DebuggerEvent) => void) | ((e: vue.DebuggerEvent) => void)[];
            renderTriggered?: ((e: vue.DebuggerEvent) => void) | ((e: vue.DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: vue.ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, vue.ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>, info: string) => boolean | void) | ((err: unknown, instance: vue.ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, vue.ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof vue.nextTick;
        $watch(source: string | Function, cb: Function, options?: vue.WatchOptions<boolean>): vue.WatchStopHandle;
    } & Readonly<vue.ExtractPropTypes<{
        query: {
            type: (ObjectConstructor | StringConstructor)[];
            required: true;
        };
        variables: {
            type: ObjectConstructor;
            default: any;
        };
        cachePolicy: {
            type: StringConstructor;
            default: any;
        };
        watchVariables: {
            type: BooleanConstructor;
            default: boolean;
        };
        suspended: {
            type: BooleanConstructor;
            default: boolean;
        };
        fetchOnMount: {
            type: BooleanConstructor;
            default: boolean;
        };
    }>> & vue.ShallowUnwrapRef<BaseQueryApi<any, Record<string, any>>> & {} & vue.ComponentCustomProperties;
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & vue.ComponentOptionsBase<Readonly<vue.ExtractPropTypes<{
    query: {
        type: (ObjectConstructor | StringConstructor)[];
        required: true;
    };
    variables: {
        type: ObjectConstructor;
        default: any;
    };
    cachePolicy: {
        type: StringConstructor;
        default: any;
    };
    watchVariables: {
        type: BooleanConstructor;
        default: boolean;
    };
    suspended: {
        type: BooleanConstructor;
        default: boolean;
    };
    fetchOnMount: {
        type: BooleanConstructor;
        default: boolean;
    };
}>>, BaseQueryApi<any, Record<string, any>>, unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, Record<string, any>, string, {
    suspended: boolean;
    variables: Record<string, any>;
    cachePolicy: string;
    fetchOnMount: boolean;
    watchVariables: boolean;
}> & vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps & (new () => {
    $slots: {
        default: (arg: QuerySlotProps$1) => VNode[];
    };
});

declare type QuerySlotProps = UnwrapRef<Pick<BaseQueryApi, 'data' | 'error' | 'execute' | 'isDone' | 'isFetching'>>;
declare const Mutation: {
    new (...args: any[]): {
        $: vue.ComponentInternalInstance;
        $data: {};
        $props: Partial<{}> & Omit<Readonly<vue.ExtractPropTypes<{
            query: {
                type: (ObjectConstructor | StringConstructor)[];
                required: true;
            };
        }>> & vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, never>;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: vue.Slot;
        }>;
        $root: vue.ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, vue.ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>;
        $parent: vue.ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, vue.ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>;
        $emit: (event: string, ...args: any[]) => void;
        $el: any;
        $options: vue.ComponentOptionsBase<Readonly<vue.ExtractPropTypes<{
            query: {
                type: (ObjectConstructor | StringConstructor)[];
                required: true;
            };
        }>>, () => VNode<vue.RendererNode, vue.RendererElement, {
            [key: string]: any;
        }>[], unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, Record<string, any>, string, {}> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: vue.DebuggerEvent) => void) | ((e: vue.DebuggerEvent) => void)[];
            renderTriggered?: ((e: vue.DebuggerEvent) => void) | ((e: vue.DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: vue.ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, vue.ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>, info: string) => boolean | void) | ((err: unknown, instance: vue.ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, vue.ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof vue.nextTick;
        $watch(source: string | Function, cb: Function, options?: vue.WatchOptions<boolean>): vue.WatchStopHandle;
    } & Readonly<vue.ExtractPropTypes<{
        query: {
            type: (ObjectConstructor | StringConstructor)[];
            required: true;
        };
    }>> & vue.ShallowUnwrapRef<() => VNode<vue.RendererNode, vue.RendererElement, {
        [key: string]: any;
    }>[]> & {} & vue.ComponentCustomProperties;
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & vue.ComponentOptionsBase<Readonly<vue.ExtractPropTypes<{
    query: {
        type: (ObjectConstructor | StringConstructor)[];
        required: true;
    };
}>>, () => VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}>[], unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, Record<string, any>, string, {}> & vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps & (new () => {
    $slots: {
        default: (arg: QuerySlotProps) => VNode[];
    };
});

interface SubscriptionSlotProps {
    data: unknown;
    error: CombinedError | null;
    isPaused: boolean;
    pause(): void;
    resume(): void;
}
declare const Subscription: {
    new (...args: any[]): {
        $: vue.ComponentInternalInstance;
        $data: {};
        $props: Partial<{
            reduce: Function;
            paused: boolean;
            variables: Record<string, any>;
        }> & Omit<Readonly<vue.ExtractPropTypes<{
            query: {
                type: (ObjectConstructor | StringConstructor)[];
                required: true;
            };
            variables: {
                type: ObjectConstructor;
                default: any;
            };
            paused: {
                type: BooleanConstructor;
                default: boolean;
            };
            reduce: {
                type: FunctionConstructor;
                default: any;
            };
        }>> & vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps, "reduce" | "paused" | "variables">;
        $attrs: {
            [x: string]: unknown;
        };
        $refs: {
            [x: string]: unknown;
        };
        $slots: Readonly<{
            [name: string]: vue.Slot;
        }>;
        $root: vue.ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, vue.ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>;
        $parent: vue.ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, vue.ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>;
        $emit: (event: string, ...args: any[]) => void;
        $el: any;
        $options: vue.ComponentOptionsBase<Readonly<vue.ExtractPropTypes<{
            query: {
                type: (ObjectConstructor | StringConstructor)[];
                required: true;
            };
            variables: {
                type: ObjectConstructor;
                default: any;
            };
            paused: {
                type: BooleanConstructor;
                default: boolean;
            };
            reduce: {
                type: FunctionConstructor;
                default: any;
            };
        }>>, () => VNode<vue.RendererNode, vue.RendererElement, {
            [key: string]: any;
        }>[], unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, Record<string, any>, string, {
            reduce: Function;
            paused: boolean;
            variables: Record<string, any>;
        }> & {
            beforeCreate?: (() => void) | (() => void)[];
            created?: (() => void) | (() => void)[];
            beforeMount?: (() => void) | (() => void)[];
            mounted?: (() => void) | (() => void)[];
            beforeUpdate?: (() => void) | (() => void)[];
            updated?: (() => void) | (() => void)[];
            activated?: (() => void) | (() => void)[];
            deactivated?: (() => void) | (() => void)[];
            beforeDestroy?: (() => void) | (() => void)[];
            beforeUnmount?: (() => void) | (() => void)[];
            destroyed?: (() => void) | (() => void)[];
            unmounted?: (() => void) | (() => void)[];
            renderTracked?: ((e: vue.DebuggerEvent) => void) | ((e: vue.DebuggerEvent) => void)[];
            renderTriggered?: ((e: vue.DebuggerEvent) => void) | ((e: vue.DebuggerEvent) => void)[];
            errorCaptured?: ((err: unknown, instance: vue.ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, vue.ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>, info: string) => boolean | void) | ((err: unknown, instance: vue.ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, vue.ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>>, info: string) => boolean | void)[];
        };
        $forceUpdate: () => void;
        $nextTick: typeof vue.nextTick;
        $watch(source: string | Function, cb: Function, options?: vue.WatchOptions<boolean>): vue.WatchStopHandle;
    } & Readonly<vue.ExtractPropTypes<{
        query: {
            type: (ObjectConstructor | StringConstructor)[];
            required: true;
        };
        variables: {
            type: ObjectConstructor;
            default: any;
        };
        paused: {
            type: BooleanConstructor;
            default: boolean;
        };
        reduce: {
            type: FunctionConstructor;
            default: any;
        };
    }>> & vue.ShallowUnwrapRef<() => VNode<vue.RendererNode, vue.RendererElement, {
        [key: string]: any;
    }>[]> & {} & vue.ComponentCustomProperties;
    __isFragment?: never;
    __isTeleport?: never;
    __isSuspense?: never;
} & vue.ComponentOptionsBase<Readonly<vue.ExtractPropTypes<{
    query: {
        type: (ObjectConstructor | StringConstructor)[];
        required: true;
    };
    variables: {
        type: ObjectConstructor;
        default: any;
    };
    paused: {
        type: BooleanConstructor;
        default: boolean;
    };
    reduce: {
        type: FunctionConstructor;
        default: any;
    };
}>>, () => VNode<vue.RendererNode, vue.RendererElement, {
    [key: string]: any;
}>[], unknown, {}, {}, vue.ComponentOptionsMixin, vue.ComponentOptionsMixin, Record<string, any>, string, {
    reduce: Function;
    paused: boolean;
    variables: Record<string, any>;
}> & vue.VNodeProps & vue.AllowedComponentProps & vue.ComponentCustomProps & (new () => {
    $slots: {
        default: (arg: SubscriptionSlotProps) => VNode[];
    };
});

declare function useClient(opts: ClientOptions): Client;

interface MutationExecutionOptions {
    context: MaybeRef<QueryExecutionContext>;
    client?: Client;
}
declare function useMutation<TData = any, TVars = QueryVariables>(query: Operation<TData, TVars>['query'], opts?: Partial<MutationExecutionOptions>): {
    data: Ref<TData>;
    isFetching: Ref<boolean>;
    isDone: Ref<boolean>;
    error: Ref<CombinedError>;
    execute: (variables?: TVars) => Promise<{
        data: TData;
        error: CombinedError;
    }>;
};

interface SubscriptionCompositeOptions<TData, TVars> {
    query: MaybeRef<Operation<TData, TVars>['query']>;
    variables?: MaybeRef<TVars>;
    paused?: boolean;
    client?: Client;
}
declare type Reducer<TData = any, TResult = TData> = (prev: TResult | null, value: OperationResult<TData>) => TResult;
declare function useSubscription<TData = any, TResult = TData, TVars = QueryVariables>(opts: SubscriptionCompositeOptions<TData, TVars>, reduce?: Reducer<TData, TResult>): {
    data: Ref<vue.UnwrapRef<TResult>>;
    error: Ref<CombinedError>;
    isPaused: Ref<boolean>;
    pause: () => void;
    resume: () => Promise<void>;
};

declare type SubscriptionForwarder<TData = any> = (operation: ClientPluginOperation) => ObservableLike<StandardOperationResult<TData>>;
declare function handleSubscriptions(forwarder: SubscriptionForwarder): ClientPlugin;

interface FetchPluginOpts {
    fetch?: typeof window['fetch'];
}
declare function fetch(opts?: FetchPluginOpts): ClientPlugin;

declare function cache(): ClientPlugin;

declare function dedup(): ClientPlugin;

declare function definePlugin(fn: ClientPlugin): ClientPlugin;

declare const VILLUS_CLIENT: InjectionKey<Client>;

export { AfterQueryCallback, BaseQueryApi, CachePolicy, Client, ClientOptions, ClientPlugin, ClientPluginContext, ClientPluginOperation, CombinedError, MaybeLazyOrRef, MaybeRef, Mutation, ObservableLike, ObserverLike, OperationResult, OperationType, OperationWithCachePolicy, Provider, Query, QueryApi, QueryCompositeOptions, QueryExecutionContext, QueryVariables, Reducer, SkipQuery, StandardOperationResult, Subscription, SubscriptionForwarder, Unsubscribable, VILLUS_CLIENT, cache, createClient, dedup, defaultPlugins, definePlugin, fetch, getActiveClient, getQueryKey, handleSubscriptions, setActiveClient, useClient, useMutation, useQuery, useSubscription, withProvider };
